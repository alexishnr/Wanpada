{"version":3,"sources":["User.js"],"names":["async","let","dfd","Deferred","server","http","createServer","req","res","method","url","body","on","data","resolve","qs","parse","writeHead","end","err","socket","connections","conn","key","remoteAddress","remotePort","destroy","cb","close","port","await","freeportAsync","listen","callbackURL","getTokenInfoAsync","promise","_startLoginServerAsync","AUTH0_DOMAIN","AUTHENTICATION_SERVER_TIMEOUT","UserManagerInstance","clientID","loginServer","refreshSessionThreshold","_currentUser","_getSessionLock","static","getGlobalInstance","__globalInstance","initialize","loginAsync","loginType","loginArgs","loginOptions","Error","apiAnonymous","ApiV2Client","clientForUser","loginResp","postAsync","username","password","clientId","testSession","error","ErrorCode","INVALID_USERNAME_PASSWORD","_getProfileAsync","currentConnection","accessToken","access_token","refreshToken","refresh_token","idToken","id_token","refreshTokenClientId","sessionSecret","connection","scope","responseMode","responseType","device","auth0Options","destroyServerTimer","setTimeout","listening","redirectUri","_auth0SocialLogin","tokenInfo","clearTimeout","profile","registerAsync","userData","user","getCurrentUserAsync","kind","userMetadata","onboarded","logoutAsync","shouldUpdateUsernamePassword","currentUser","shouldLinkAccount","registeredUser","createOrUpdateUserAsync","email","givenName","familyName","emailVerified","forceCreate","linkedAccountId","userId","linkedAccountConnection","loginsCount","e","REGISTRATION_ERROR","message","migrateAuth0ToSessionAsync","options","testMode","hasCachedSession","UserSettings","getAsync","api","response","mergeAsync","auth","ensureLoggedInAsync","noTrackError","Config","offline","getLegacyUserData","LEGACY_ACCOUNT_ERROR","noTrack","NOT_LOGGED_IN","acquire","_isTokenExpired","Logger","global","release","legacyUsername","legacy","needsPasswordMigration","updatedUser","_prepareAuth0Profile","_parseAuth0Profile","code","details","Analytics","logEvent","deleteKeyAsync","Intercom","update","forgotPasswordAsync","usernameOrEmail","dtoken","jwt","decode","complete","aud","payload","currentRefreshTokenClientId","dateAuth0Gone","Date","now","delegationResult","_auth0RefreshToken","setUserProperties","intercomUserHash","exp","process","env","NODE_ENV","debug","isNode","opn","_buildAuth0SocialLoginUrl","wait","webAuth","_auth0WebAuthInstanceWithOptions","authorize","delegationTokenOptions","api_type","target","client_id","grant_type","window","delegationAsync","promisify","client","delegation","bind","Auth0Node","_nodeAuth0InstanceWithOptions","tokens","getDelegationToken","_formatAuth0NodeError","errData","TOO_MANY_ATTEMPTS","error_description","qsData","response_type","response_mode","redirect_uri","queryString","stringify","auth0","require","domain","_disableDeprecationWarnings","WebAuth","Auth0Instance","management","_","omit","ManagementClient","AuthenticationClient","rawProfile","Object","keys","reduce","p","camelCase","niceProfile","snakeCase","constructor","Promise","reject"],"mappings":"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","file":"../User.js","sourcesContent":["/**\n * @flow\n */\n\nimport _ from 'lodash';\nimport freeportAsync from 'freeport-async';\nimport http from 'http';\nimport qs from 'querystring';\nimport opn from 'opn';\nimport jwt from 'jsonwebtoken';\nimport promisify from 'util.promisify';\n\nimport type { WebAuth } from 'auth0-js';\nimport type Auth0Node from 'auth0';\n\nimport ApiV2Client, { ApiV2Error } from './ApiV2';\n\nimport * as Analytics from './Analytics';\nimport Config from './Config';\nimport ErrorCode from './ErrorCode';\nimport XDLError from './XDLError';\nimport Logger from './Logger';\n\nimport * as Intercom from './Intercom';\nimport UserSettings from './UserSettings';\n\nimport { Semaphore } from './Utils';\nimport { isNode } from './tools/EnvironmentHelper';\n\nexport type User = {\n  kind: 'user',\n  // required\n  name: string,\n  username: string,\n  nickname: string,\n  userId: string,\n  picture: string,\n  // optional\n  email?: string,\n  emailVerified?: boolean,\n  givenName?: string,\n  familyName?: string,\n  loginsCount?: number,\n  intercomUserHash: string,\n  userMetadata: {\n    onboarded: boolean,\n    legacy?: boolean,\n  },\n  identities: Array<{\n    connection: ConnectionType,\n    isSocial: boolean,\n    provider: string,\n    userId: string,\n  }>,\n  accessToken: string,\n  idToken: string,\n  refreshToken: string,\n  currentConnection: ConnectionType,\n  sessionSecret: string,\n};\n\nexport type LegacyUser = {\n  kind: 'legacyUser',\n  username: string,\n  userMetadata: {\n    legacy: boolean,\n    needsPasswordMigration: boolean,\n  },\n};\n\nexport type UserOrLegacyUser = User | LegacyUser;\n\ntype ConnectionType = 'Username-Password-Authentication' | 'facebook' | 'google-oauth2' | 'github';\n\ntype LoginOptions = {\n  connection: ConnectionType,\n  device: string,\n  responseType: string,\n  responseMode: string,\n  username?: string,\n  password?: string,\n};\n\nexport type RegistrationData = {\n  username: string,\n  password: string,\n  email?: string,\n  givenName?: string,\n  familyName?: string,\n};\n\ntype Auth0Options = {\n  clientID: string,\n  redirectUri?: string,\n};\n\nexport type LoginType = 'user-pass' | 'facebook' | 'google' | 'github';\n\nconst AUTH0_DOMAIN = 'exponent.auth0.com';\nconst AUTHENTICATION_SERVER_TIMEOUT = 1000 * 60 * 5; // 5 minutes\n\nexport class UserManagerInstance {\n  clientID = 'o0YygTgKhOTdoWj10Yl9nY2P0SMTw38Y'; // Default Client ID\n  loginServer = null;\n  refreshSessionThreshold = 60 * 60; // 1 hour\n  _currentUser: ?User = null;\n  _getSessionLock = new Semaphore();\n\n  static getGlobalInstance() {\n    if (!__globalInstance) {\n      __globalInstance = new UserManagerInstance();\n    }\n    return __globalInstance;\n  }\n\n  initialize(clientID: ?string) {\n    if (clientID) {\n      this.clientID = clientID;\n    }\n    this.loginServer = null;\n    this._currentUser = null;\n    this._getSessionLock = new Semaphore();\n  }\n\n  /**\n   * Logs in a user for a given login type.\n   *\n   * Valid login types are:\n   *  - \"user-pass\": Username and password authentication\n   *  - \"facebook\": Facebook authentication\n   *  - \"google\": Google authentication\n   *  - \"github\": Github authentication\n   *\n   * If the login type is \"user-pass\", we directly make the request to Auth0\n   * to login a user.\n   *\n   * If the login type is any of the social providers, we start a web server\n   * that can act as the receiver of the OAuth callback from the authentication\n   * process. The response we receive on that web server will be token data.\n   */\n  async loginAsync(\n    loginType: LoginType,\n    loginArgs?: { username: string, password: string, testSession?: boolean }\n  ): Promise<User> {\n    let loginOptions;\n\n    if (loginType === 'user-pass') {\n      if (!loginArgs) {\n        throw new Error(`The 'user-pass' login type requires a username and password.`);\n      }\n      const apiAnonymous = ApiV2Client.clientForUser();\n      const loginResp = await apiAnonymous.postAsync('auth/loginAsync', {\n        username: loginArgs.username,\n        password: loginArgs.password,\n        clientId: this.clientID,\n        ...(loginArgs.testSession ? { testSession: loginArgs.testSession } : {}),\n      });\n      if (loginResp.error) {\n        throw new XDLError(ErrorCode.INVALID_USERNAME_PASSWORD, loginResp['error_description']);\n      }\n      return this._getProfileAsync({\n        currentConnection: 'Username-Password-Authentication',\n        accessToken: loginResp.access_token,\n        refreshToken: loginResp.refresh_token,\n        idToken: loginResp.id_token,\n        refreshTokenClientId: this.clientID,\n        sessionSecret: loginResp.sessionSecret,\n      });\n    } else if (loginType === 'facebook') {\n      loginOptions = {\n        connection: 'facebook',\n      };\n    } else if (loginType === 'google') {\n      loginOptions = {\n        connection: 'google-oauth2',\n      };\n    } else if (loginType === 'github') {\n      loginOptions = {\n        connection: 'github',\n      };\n    } else {\n      throw new Error(\n        `Invalid login type provided. Must be one of 'user-pass', 'facebook', 'google', or 'github'.`\n      );\n    }\n\n    loginOptions = {\n      ...loginOptions,\n      scope: 'openid offline_access username nickname',\n      // audience: 'https://exp.host',\n      responseMode: 'form_post',\n      responseType: 'token',\n      device: 'xdl',\n    };\n\n    let auth0Options = {\n      clientID: this.clientID,\n    };\n\n    // Doing a social login, so start a server\n    const { server, callbackURL, getTokenInfoAsync } = await _startLoginServerAsync();\n\n    // Kill server after 5 minutes if it hasn't already been closed\n    const destroyServerTimer = setTimeout(() => {\n      if (server.listening) {\n        server.destroy();\n      }\n    }, AUTHENTICATION_SERVER_TIMEOUT);\n\n    auth0Options = {\n      clientID: this.clientID,\n      redirectUri: callbackURL,\n    };\n\n    // Don't await -- we'll get response back through server\n    // This will open a browser window\n    this._auth0SocialLogin(auth0Options, loginOptions);\n\n    // Wait for token info to come back from server\n    const tokenInfo = await getTokenInfoAsync();\n\n    server.destroy();\n    clearTimeout(destroyServerTimer);\n\n    const profile = await this._getProfileAsync({\n      currentConnection: loginOptions.connection,\n      accessToken: tokenInfo.access_token,\n      refreshToken: tokenInfo.refresh_token,\n      idToken: tokenInfo.id_token,\n      refreshTokenClientId: this.clientID,\n    });\n\n    return profile;\n  }\n\n  async registerAsync(userData: RegistrationData, user: ?UserOrLegacyUser): Promise<User> {\n    if (!user) {\n      user = await this.getCurrentUserAsync();\n    }\n\n    if (user && user.kind === 'user' && user.userMetadata && user.userMetadata.onboarded) {\n      await this.logoutAsync();\n      user = null;\n    }\n\n    let shouldUpdateUsernamePassword = true;\n    if (user && user.kind === 'legacyUser') {\n      // we're upgrading from an older client,\n      // so login with username/pass\n      if (userData.username && userData.password) {\n        user = await this.loginAsync('user-pass', {\n          username: userData.username,\n          password: userData.password,\n        });\n      }\n      shouldUpdateUsernamePassword = false;\n    }\n\n    const currentUser: ?User = (user: any);\n\n    const shouldLinkAccount =\n      currentUser && currentUser.currentConnection !== 'Username-Password-Authentication';\n\n    try {\n      // Create or update the profile\n      let registeredUser = await this.createOrUpdateUserAsync({\n        connection: 'Username-Password-Authentication', // Always create/update username password\n        email: userData.email,\n        userMetadata: {\n          onboarded: true,\n          givenName: userData.givenName,\n          familyName: userData.familyName,\n        },\n        ...(shouldUpdateUsernamePassword ? { username: userData.username } : {}),\n        ...(shouldLinkAccount ? { emailVerified: true } : {}),\n        ...(shouldUpdateUsernamePassword ? { password: userData.password } : {}),\n        ...(currentUser && shouldLinkAccount\n          ? {\n              forceCreate: true,\n              linkedAccountId: currentUser.userId,\n              linkedAccountConnection: currentUser.currentConnection,\n            }\n          : {}),\n      });\n\n      // if it's a new registration, or if they signed up with a social account,\n      // we need to re-log them in with their username/pass. Otherwise, they're\n      // already logged in.\n      if (\n        shouldLinkAccount ||\n        (registeredUser &&\n          (!registeredUser.loginsCount ||\n            (registeredUser.loginsCount && registeredUser.loginsCount < 1)))\n      ) {\n        // this is a new registration, log them in\n        registeredUser = await this.loginAsync('user-pass', {\n          username: userData.username,\n          password: userData.password,\n        });\n      }\n\n      return registeredUser;\n    } catch (e) {\n      throw new XDLError(ErrorCode.REGISTRATION_ERROR, 'Error registering user: ' + e.message);\n    }\n  }\n\n  /**\n   * Migrate a user from auth0 tokens to sessions\n   * TODO: remove when everyone is migrated to sessions\n   */\n  async migrateAuth0ToSessionAsync(options: { [string]: any } = { testMode: false }) {\n    const { testMode } = options;\n    // If logged in but using legacy auth0 tokens, migrate to sessions\n    const user = await this.getCurrentUserAsync();\n    if (!user) {\n      return;\n    }\n    const hasCachedSession = this._currentUser && this._currentUser.sessionSecret;\n    if (hasCachedSession) {\n      return;\n    }\n\n    // check for sessionSecret in state.json file\n    let { sessionSecret } = await UserSettings.getAsync('auth', {});\n    if (sessionSecret) {\n      return;\n    }\n    let api = ApiV2Client.clientForUser({\n      idToken: user.idToken,\n      accessToken: user.accessToken,\n    });\n\n    try {\n      // get sessionSecret and save it\n      const response = await api.postAsync('auth/auth0ToSession', {\n        ...(testMode ? { testSession: testMode } : {}),\n      });\n      const { sessionSecret } = response;\n      if (sessionSecret) {\n        user.sessionSecret = sessionSecret;\n        await UserSettings.mergeAsync({\n          auth: {\n            sessionSecret,\n          },\n        });\n      }\n      return response;\n    } catch (e) {}\n  }\n\n  /**\n   * Ensure user is logged in and has a valid token.\n   *\n   * If there are any issues with the login, this method throws.\n   */\n  async ensureLoggedInAsync(\n    options: { noTrackError: boolean } = { noTrackError: false }\n  ): Promise<?User> {\n    if (Config.offline) {\n      return null;\n    }\n\n    // migrate from auth0 to sessions, if available\n    await this.migrateAuth0ToSessionAsync();\n\n    const user = await this.getCurrentUserAsync();\n    if (!user) {\n      if (await this.getLegacyUserData()) {\n        throw new XDLError(\n          ErrorCode.LEGACY_ACCOUNT_ERROR,\n          `We've updated our account system! Please login again by running \\`exp login\\`. Sorry for the inconvenience!`,\n          { noTrack: options.noTrackError }\n        );\n      }\n      throw new XDLError(ErrorCode.NOT_LOGGED_IN, 'Not logged in', {\n        noTrack: options.noTrackError,\n      });\n    }\n    return user;\n  }\n\n  /**\n   * Get the current user based on the available token.\n   * If there is no current token, returns null.\n   */\n  async getCurrentUserAsync(): Promise<?User> {\n    await this._getSessionLock.acquire();\n\n    try {\n      // If user is cached and there is a sessionSecret, or the Auth0 token isn't expired\n      // return the user\n      if (this._currentUser) {\n        if (this._currentUser.sessionSecret || !this._isTokenExpired(this._currentUser.idToken)) {\n          return this._currentUser;\n        }\n      }\n\n      if (Config.offline) {\n        return null;\n      }\n\n      // Not cached, check for token\n      let {\n        currentConnection,\n        idToken,\n        accessToken,\n        refreshToken,\n        sessionSecret,\n      } = await UserSettings.getAsync('auth', {});\n\n      // No tokens/session, no current user. Need to login\n      if ((!currentConnection || !idToken || !accessToken || !refreshToken) && !sessionSecret) {\n        return null;\n      }\n\n      try {\n        return await this._getProfileAsync({\n          currentConnection,\n          accessToken,\n          idToken,\n          refreshToken,\n          sessionSecret,\n        });\n      } catch (e) {\n        Logger.global.error(e);\n        // This logs us out if theres a fatal error when getting the profile with\n        // current access token\n        // However, this also logs us out if there is a network error\n        await this.logoutAsync();\n        return null;\n      }\n    } finally {\n      this._getSessionLock.release();\n    }\n  }\n\n  /**\n   * Get legacy user data from UserSettings.\n   */\n  async getLegacyUserData(): Promise<?LegacyUser> {\n    const legacyUsername = await UserSettings.getAsync('username', null);\n    if (legacyUsername) {\n      return {\n        kind: 'legacyUser',\n        username: legacyUsername,\n        userMetadata: {\n          legacy: true,\n          needsPasswordMigration: true,\n        },\n      };\n    }\n    return null;\n  }\n\n  /**\n   * Create or update a user.\n   */\n  async createOrUpdateUserAsync(userData: Object): Promise<User> {\n    let currentUser = this._currentUser;\n    if (!currentUser) {\n      // attempt to get the current user\n      currentUser = await this.getCurrentUserAsync();\n    }\n\n    try {\n      const api = ApiV2Client.clientForUser(this._currentUser);\n\n      const { user: updatedUser } = await api.postAsync('auth/createOrUpdateUser', {\n        userData: _prepareAuth0Profile(userData),\n      });\n\n      this._currentUser = {\n        ...(this._currentUser || {}),\n        ..._parseAuth0Profile(updatedUser),\n      };\n      return {\n        kind: 'user',\n        ...this._currentUser,\n      };\n    } catch (e) {\n      const err: ApiV2Error = (e: any);\n      if (err.code === 'AUTHENTICATION_ERROR') {\n        throw new Error(err.details.message);\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Logout\n   */\n  async logoutAsync(): Promise<void> {\n    if (this._currentUser) {\n      Analytics.logEvent('Logout', {\n        username: this._currentUser.username,\n      });\n    }\n\n    this._currentUser = null;\n\n    // Delete saved JWT\n    await UserSettings.deleteKeyAsync('auth');\n    // Delete legacy auth\n    await UserSettings.deleteKeyAsync('username');\n\n    // Logout of Intercom\n    Intercom.update(null);\n  }\n\n  /**\n   * Forgot Password\n   */\n  async forgotPasswordAsync(usernameOrEmail: string): Promise<void> {\n    const apiAnonymous = ApiV2Client.clientForUser();\n    return apiAnonymous.postAsync('auth/forgotPasswordAsync', {\n      usernameOrEmail,\n      clientId: this.clientID,\n    });\n  }\n\n  /**\n   * Get profile given token data. Errors if token is not valid or if no\n   * user profile is returned.\n   *\n   * This method is called by all public authentication methods of `UserManager`\n   * except `logoutAsync`. Therefore, we use this method as a way to:\n   *  - update the UserSettings store with the current token and user id\n   *  - update UserManager._currentUser\n   *  - Fire login analytics events\n   *  - Update the currently assigned Intercom user\n   *\n   * Also updates UserManager._currentUser.\n   *\n   * @private\n   */\n  async _getProfileAsync({\n    currentConnection,\n    accessToken,\n    idToken,\n    refreshToken,\n    refreshTokenClientId,\n    sessionSecret,\n  }: {\n    currentConnection: ConnectionType,\n    accessToken?: string,\n    idToken?: string,\n    refreshToken?: string,\n    refreshTokenClientId?: string,\n    sessionSecret?: string,\n  }): Promise<User> {\n    let user;\n    if (!sessionSecret) {\n      // Attempt to grab profile from Auth0.\n      // If token is expired / getting the profile fails, use refresh token to\n      try {\n        const dtoken = jwt.decode(idToken, { complete: true });\n        const { aud } = dtoken.payload;\n\n        // If it's not a new login, refreshTokenClientId won't be set in the arguments.\n        // In this case, try to get the currentRefreshTokenClientId from UserSettings,\n        // otherwise, default back to the audience of the current id_token\n        if (!refreshTokenClientId) {\n          const { refreshTokenClientId: currentRefreshTokenClientId } = await UserSettings.getAsync(\n            'auth',\n            {}\n          );\n          if (!currentRefreshTokenClientId) {\n            refreshTokenClientId = aud; // set it to the \"aud\" property of the existing token\n          } else {\n            refreshTokenClientId = currentRefreshTokenClientId;\n          }\n        }\n        if (this._isTokenExpired(idToken)) {\n          // User has expired token and no session -- they need to log back in if Auth0 is gone\n          const dateAuth0Gone = new Date(2018, 3, 2); // April 1, 2018 - the months are 0 indexed\n          if (Date.now() > dateAuth0Gone) {\n            await this.logoutAsync();\n            throw new XDLError('Tokens expired, logging out. Please try again.');\n          }\n          const delegationResult = await this._auth0RefreshToken(\n            refreshTokenClientId, // client id that's associated with the refresh token\n            refreshToken // refresh token to use\n          );\n          idToken = delegationResult.id_token;\n        }\n      } catch (e) {\n        throw e;\n      }\n    }\n\n    let api = ApiV2Client.clientForUser({\n      idToken,\n      accessToken,\n      sessionSecret,\n    });\n\n    user = await api.postAsync('auth/userProfileAsync', { clientId: this.clientID });\n\n    if (!user) {\n      throw new Error('Unable to fetch user.');\n    }\n\n    user = {\n      ..._parseAuth0Profile(user),\n      kind: 'user',\n      currentConnection,\n      ...(accessToken ? { accessToken } : {}),\n      ...(idToken ? { idToken } : {}),\n      ...(refreshToken ? { refreshToken } : {}),\n      ...(sessionSecret ? { sessionSecret } : {}),\n    };\n\n    await UserSettings.mergeAsync({\n      auth: {\n        userId: user.userId,\n        username: user.username,\n        currentConnection,\n        ...(accessToken ? { accessToken } : {}),\n        ...(idToken ? { idToken } : {}),\n        ...(refreshToken ? { refreshToken } : {}),\n        ...(refreshTokenClientId ? { refreshTokenClientId } : {}),\n        ...(sessionSecret ? { sessionSecret } : {}),\n      },\n    });\n\n    await UserSettings.deleteKeyAsync('username');\n\n    // If no currentUser, or currentUser.id differs from profiles\n    // user id, that means we have a new login\n    if (\n      (!this._currentUser || this._currentUser.userId !== user.userId) &&\n      user.username &&\n      user.username !== ''\n    ) {\n      Analytics.logEvent('Login', {\n        userId: user.userId,\n        currentConnection: user.currentConnection,\n        username: user.username,\n      });\n\n      Analytics.setUserProperties(user.username, {\n        userId: user.userId,\n        currentConnection: user.currentConnection,\n        username: user.username,\n      });\n\n      if (user.intercomUserHash) {\n        Intercom.update(user);\n      }\n    } else {\n      Intercom.update(null);\n    }\n\n    this._currentUser = user;\n\n    return user;\n  }\n\n  _isTokenExpired(idToken: string): boolean {\n    const dtoken = jwt.decode(idToken, { complete: true });\n    const { exp } = dtoken.payload;\n    // TODO(@skevy): remove\n    if (process.env.NODE_ENV !== 'production') {\n      Logger.global.debug('TOKEN EXPIRATION', exp);\n    }\n    // TODO(@skevy): remove\n    if (process.env.NODE_ENV !== 'production') {\n      Logger.global.debug('TOKEN TIME LEFT', exp - Date.now() / 1000);\n    }\n\n    return exp - Date.now() / 1000 <= this.refreshSessionThreshold;\n  }\n\n  _auth0SocialLogin(auth0Options: Auth0Options, loginOptions: LoginOptions) {\n    if (isNode()) {\n      opn(_buildAuth0SocialLoginUrl(auth0Options, loginOptions), {\n        wait: false,\n      });\n    } else {\n      const webAuth = _auth0WebAuthInstanceWithOptions(auth0Options);\n      webAuth.authorize(loginOptions);\n    }\n  }\n\n  async _auth0RefreshToken(clientId: string, refreshToken: string): Promise<*> {\n    const delegationTokenOptions = {\n      refresh_token: refreshToken,\n      api_type: 'app',\n      scope: 'openid offline_access nickname username',\n      target: this.clientID,\n      client_id: clientId,\n      grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n    };\n\n    if (typeof window !== 'undefined' && window) {\n      const webAuth = _auth0WebAuthInstanceWithOptions({ clientID: clientId });\n      const delegationAsync = promisify(webAuth.client.delegation.bind(webAuth.client));\n      return await delegationAsync(delegationTokenOptions);\n    }\n\n    const Auth0Node = _nodeAuth0InstanceWithOptions({\n      clientID: this.clientID,\n    });\n\n    const delegationResult = await Auth0Node.tokens.getDelegationToken(delegationTokenOptions);\n\n    return delegationResult;\n  }\n}\n\nlet __globalInstance;\nexport default UserManagerInstance.getGlobalInstance();\n\n/** Private Methods **/\n\ntype APIError = Error & {\n  name: string,\n  statusCode: string,\n};\n\ntype ErrorWithDescription = Error & {\n  description?: string,\n};\n\nfunction _formatAuth0NodeError(e: APIError) {\n  // TODO: Fix the Auth0 js library to throw better error messages when the network fails.\n  // Auth0 returns an error object whenver Auth0 fails to make an API request.\n  // These error messages are usually well-formed when you have an invalid login or too many attempts,\n  // but when the network is down it does not give any meaningful messages.\n  // Network failures log the user out in _getCurrentUserAsync() when it uses Auth0.\n  const errData = e.message;\n  switch (errData.error) {\n    case 'invalid_user_password':\n      return new XDLError(ErrorCode.INVALID_USERNAME_PASSWORD, 'Invalid username or password');\n    case 'too_many_attempts':\n      return new XDLError(ErrorCode.TOO_MANY_ATTEMPTS, errData.error_description);\n    default:\n      return new Error(errData.error_description);\n  }\n  return e;\n}\n\nfunction _buildAuth0SocialLoginUrl(auth0Options: Auth0Options, loginOptions: LoginOptions) {\n  const qsData = {\n    scope: 'openid offline_access username nickname',\n    response_type: loginOptions.responseType,\n    response_mode: loginOptions.responseMode,\n    connection: loginOptions.connection,\n    device: 'xdl',\n    client_id: auth0Options.clientID,\n    redirect_uri: auth0Options.redirectUri,\n  };\n\n  const queryString = qs.stringify(qsData);\n\n  return `https://${AUTH0_DOMAIN}/authorize?${queryString}`;\n}\n\nfunction _auth0WebAuthInstanceWithOptions(options: Auth0Options): WebAuth {\n  const auth0 = require('auth0-js');\n\n  let auth0Options = {\n    domain: AUTH0_DOMAIN,\n    responseType: 'token',\n    _disableDeprecationWarnings: true,\n    ...options,\n  };\n\n  return new auth0.WebAuth(auth0Options);\n}\n\nfunction _nodeAuth0InstanceWithOptions(options: Object = {}): any {\n  let auth0Options = {\n    domain: AUTH0_DOMAIN,\n    clientId: options.clientID || options.clientId,\n    ...options,\n  };\n\n  let Auth0Instance;\n  if (auth0Options.management === true) {\n    auth0Options = _.omit(auth0Options, 'management');\n    const ManagementClient = require('auth0').ManagementClient;\n    Auth0Instance = new ManagementClient(auth0Options);\n  } else {\n    const AuthenticationClient = require('auth0').AuthenticationClient;\n    Auth0Instance = new AuthenticationClient(auth0Options);\n  }\n\n  return Auth0Instance;\n}\n\nfunction _parseAuth0Profile(rawProfile: any): User {\n  if (!rawProfile || typeof rawProfile !== 'object') {\n    return rawProfile;\n  }\n  return ((Object.keys(rawProfile).reduce((p, key) => {\n    p[_.camelCase(key)] = _parseAuth0Profile(rawProfile[key]);\n    return p;\n  }, {}): any): User);\n}\n\nfunction _prepareAuth0Profile(niceProfile: any): Object {\n  if (typeof niceProfile !== 'object') {\n    return niceProfile;\n  }\n\n  return ((Object.keys(niceProfile).reduce((p, key) => {\n    p[_.snakeCase(key)] = _prepareAuth0Profile(niceProfile[key]);\n    return p;\n  }, {}): any): User);\n}\n\ntype TokenInfo = {\n  access_token: string,\n  id_token: string,\n  refresh_token: string,\n};\n\nclass Deferred<X> {\n  promise: Promise<X>;\n  resolve: (...args: Array<*>) => void;\n  reject: (...args: Array<*>) => void;\n\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.reject = reject;\n      this.resolve = resolve;\n    });\n  }\n}\n\ntype ServerWithDestroy = {\n  destroy: Function,\n  listening: boolean,\n  on: Function,\n  close: Function,\n  listen: Function,\n};\n\nasync function _startLoginServerAsync(): Promise<{\n  server: ServerWithDestroy,\n  callbackURL: string,\n  getTokenInfoAsync: () => Promise<TokenInfo>,\n}> {\n  let dfd = new Deferred();\n\n  const server: ServerWithDestroy = ((http.createServer((req, res) => {\n    if (req.method === 'POST' && req.url === '/callback') {\n      let body = '';\n      req.on('data', function(data) {\n        body += data;\n      });\n      req.on('end', function() {\n        dfd.resolve(qs.parse(body));\n        res.writeHead(200, { 'Content-Type': 'text/html' });\n        res.end(\n          `\n          <html>\n          <head>\n            <script>\n              window.close();\n            </script>\n          </head>\n          <body>\n            Authenticated successfully! You can close this window.\n          </body>\n          </html>\n        `\n        );\n      });\n    } else {\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.end(\n        `\n        <html>\n        <head></head>\n        <body></body>\n        </html>\n      `\n      );\n    }\n  }): any): ServerWithDestroy);\n\n  server.on('clientError', (err, socket) => {\n    //eslint-disable-line\n    socket.end('HTTP/1.1 400 Bad Request\\r\\n\\r\\n');\n  });\n\n  let connections = {};\n\n  server.on('connection', function(conn) {\n    let key = conn.remoteAddress + ':' + conn.remotePort;\n    connections[key] = conn;\n    conn.on('close', function() {\n      delete connections[key];\n    });\n  });\n\n  server.destroy = function(cb) {\n    server.close(cb);\n    for (let key in connections) {\n      connections[key].destroy();\n    }\n  };\n\n  const port = await freeportAsync(11000);\n  try {\n    server.listen(port, '127.0.0.1');\n\n    return {\n      server,\n      callbackURL: `http://127.0.0.1:${port}/callback`,\n      getTokenInfoAsync: (): Promise<TokenInfo> => dfd.promise,\n    };\n  } catch (err) {\n    throw err;\n  }\n}\n"],"sourceRoot":"/xdl/src"}